/**
 * This file implements an genetic algorithm (with only mutation operators) with a self-adaptive mutation rule:
 *   For each generation, half of offsprings are generated by mutation rate = r / 2 / dimension, and the other half are generated by mutation rate = 2 * r / dimension.
 *   r will be updated as the one of r / 2 and 2 * r that is applied to generate the best offring in current generation by 0.5 probability,
 *   and as r/2 and 2*r by 0.25 probability respectively.
 *   
 * Initialized r : 2
 * Upper bound of r: dimension / 4
 * Lower bound of r : 2 
 * Size of parents: 1
 * Size of offsprings: originally set as 10
 */


/**
 * The maximal budget for evaluations done by an optimization algorithm equals dimension * BUDGET_MULTIPLIER.
 * Increase the budget multiplier value gradually to see how it affects the runtime.
 */
static const size_t BUDGET_MULTIPLIER = 50;

/**
 * The maximal number of independent restarts allowed for an algorithm that restarts itself.
 */
static const size_t INDEPENDENT_RESTARTS = 100;

/**
 * The random seed. Change it if needed.
 */
static const uint32_t RANDOM_SEED = 1;

/**
 * To generate individuals randomly. Elements of a bit-string is generated by a standard Uniform distribution. 
 */
void generatingIndividual(int * individuals,
                            const size_t dimension, 
                            IOHprofiler_random_state_t *random_generator){
  size_t i;
  for(i = 0; i < dimension; ++i){
    individuals[i] = (int)(IOHprofiler_random_uniform(random_generator) * 2);
  }
}

/**
 * To copy an individual "old" to "new", the length of the bit-string is given by "dimension".
 */
void CopyIndividual(int * old, int * new, const size_t dimension){
  size_t i;
  for(i = 0; i < dimension; ++i){
    new[i] = old[i];
  }
}

/**
 * To sample a random value by a Binomial distribution with "n" trials and a given "probability".
 */
size_t randomBinomial(size_t n, double  probability,IOHprofiler_random_state_t *random_generator)
{
    size_t r, i;
    r = 0;
    for(i = 0; i < n; ++i){
        if(IOHprofiler_random_uniform(random_generator) < probability)
        {
            ++r;
        }
    }
    return r;
}

/**
 * Mutation Operator.
 * "l" is the number of bits to be flipped, which is sample by Binomial distribution.
 * "l" positions are randomly selected by a uniform distribution.
 * A resampling strategy is applied to make sure that "l" is larger than 0. 
 */
size_t mutateIndividual(int * individual, 
                      const size_t dimension, 
                      double mutation_rate, 
                      IOHprofiler_random_state_t *random_generator){
  size_t i,h, l;
  int flag,temp;
  int * flip;

  l = randomBinomial(dimension,mutation_rate,random_generator);
  while(l == 0){
    l = randomBinomial(dimension,mutation_rate,random_generator);
  }
  
  flip = IOHprofiler_allocate_int_vector(l);
  for(i = 0; i < l; ++i){
    while(1){
      flag = 0;
      temp = (int)(IOHprofiler_random_uniform(random_generator) * dimension);
      for(h = 0; h < i; ++h)
      {
        if(temp == flip[h]){
          flag = 1;
          break;
        }
      }
      if(flag == 0)
        break;
    }
    flip[i] = temp;
  }

  for(i = 0; i < l; ++i){
    individual[flip[i]] =  ((int)(individual[flip[i]] + 1) % 2);
  }
  IOHprofiler_free_memory(flip);
  return l;
}

/**
 * An user defined algorithm.
 *
 * @param "evaluate" The function for evaluating variables' fitness. Invoking the 
 *        statement "evaluate(x,y)", then the fitness of 'x' will be stored in 'y[0]'.
 * @param "dimension" The dimension of problem.
 * @param "number_of_objectives" The number of objectives. The default is 1.
 * @param "lower_bounds" The lower bounds of the region of interested (a vector containing dimension values). 
 * @param "upper_bounds" The upper bounds of the region of interested (a vector containing dimension values). 
 * @param "max_budget" The maximal number of evaluations. You can set it by BUDGET_MULTIPLIER in "config" file.
 * @param "random_generator" Pointer to a random number generator able to produce uniformly and normally
 * distributed random numbers. You can set it by RANDOM_SEED in "config" file
 */
void User_Algorithm(evaluate_function_t evaluate,
                      const size_t dimension,
                      const size_t number_of_objectives,
                      const int *lower_bounds,
                      const int *upper_bounds,
                      const size_t max_budget,
                      IOHprofiler_random_state_t *random_generator) {

  int *parent = IOHprofiler_allocate_int_vector(dimension);
  int *offspring = IOHprofiler_allocate_int_vector(dimension);
  int *best = IOHprofiler_allocate_int_vector(dimension);
  double *y = IOHprofiler_allocate_vector(number_of_objectives);
  
  double best_value;
  size_t i, j, l;
  double r,bestr;
  double tempb;
  size_t number_of_parameters = 3;
  double *p = IOHprofiler_allocate_vector(number_of_parameters);

  int hit_optimal = 0;
  int lambda = 2;
  double mutation_rate;
  
  generatingIndividual(parent,dimension,random_generator);
  
  /* Call the evaluate function to evaluate x on the current problem (this is where all the IOHprofiler logging
   * is performed) */
  p[0] = (double)lambda; p[1] = 0.0; p[2] = 0.0;
  set_parameters(number_of_parameters,p);
  evaluate(parent,y);
  
  CopyIndividual(parent,best,dimension);
  best_value = y[0];
  r = 2;
  
  for (i = 1; i < max_budget; ) {
    tempb = 0.0;

    for(j = 0; j < lambda; ++j){
      if(j < lambda/2){
        mutation_rate = r/(double)(2*dimension);
      }else{
        mutation_rate = 2 * r / (double)(dimension);
      }

      CopyIndividual(parent,offspring,dimension);
      
      l = mutateIndividual(offspring,dimension,mutation_rate,random_generator);
      p[0] = (double)lambda; p[0] = mutation_rate; p[1] = (double)l;
      set_parameters(number_of_parameters,p);
      evaluate(offspring, y);
      ++i;
      
      if(i == max_budget) {
        break;
      }

      if(if_hit_optimal()) {
        hit_optimal = 1;
        break;
      }

      if(y[0] > tempb){
        tempb = y[0];
        bestr = mutation_rate * (double)dimension;
      }
      if(y[0] > best_value){
        best_value = y[0];
        CopyIndividual(offspring,best,dimension);
      }
    }
 
    if(hit_optimal) {
      break;   
    }

    /*Self Adaptation procedure*/
    if(IOHprofiler_random_uniform(random_generator) > 0.5){
      r = bestr;
    }else{
      if(IOHprofiler_random_uniform(random_generator) > 0.5)
        r = r / 2.0;
      else
        r = r * 2.0;
    }
    if(r < 2) r = 2;
    if(r > (double)dimension / 4.0) r = (double)dimension / 4.0;
    
    CopyIndividual(best,parent,dimension);
  }

  IOHprofiler_free_memory(parent);
  IOHprofiler_free_memory(offspring);
  IOHprofiler_free_memory(best);
  IOHprofiler_free_memory(p);
  IOHprofiler_free_memory(y);
}