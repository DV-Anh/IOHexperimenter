#' Random Search
#'
#' Random walk in \eqn{{0, 1}^d} space  
#'
#'
#' @param IOHproblem An IOHproblem object
#'
#' @export
random_search <- function(dim, obj_func, budget = NULL) {
  if (is.null(budget)) budget <- 10 * dim
  fopt <- -Inf
  
  while (budget > 0) {
    x <- sample(c(0, 1), dim, TRUE)
    f <- obj_func(x)
    budget <- budget - 1
    
    if (f > fopt) {
      xopt <- x
      fopt <- f
    }
  }
  list(xopt = x, fopt = fopt)
}

#' Random Local Search (RLS) Algorithm
#' 
#' The simplest stochastic optimization algorithm for discrete problems. A randomly 
#' chosen position in the solution vector is perturbated in each iteration. Only
#' improvements are accepted after perturbation.
#'
#' @param dim integer, the dimension of the 
#' @param obj_func the objective function to be maximized
#' @param target double, the target value to hit 
#' @param budget integer, maximal allowable number of function evaluations
#'
#' @export
#' @examples
RLS <- function(dim, obj_func, target = NULL, budget = NULL) {
  if (is.null(budget)) budget <- 10 * dim

  x <- sample(c(0, 1), dim, TRUE)
  fopt <- obj_func(x)
  budget <- budget - 1

  while (budget > 0) {
    x_ <- x
    index <- sample(dim, 1)
    x_[index] <- sample(c(0, 1), 1)
    f <- obj_func(x_)
    
    if(f > fopt) {
      fopt <- f
      x <- x_
    }
    budget <- budget - 1
  }
  list(xopt = x, fopt = fopt)
}

#' One-Comma-Lambda Self-Adapative Genetic Algorithm
#' 
#' A genetic algorithm that controls the mutation rate (strength) using the so-called 
#' self-adaptation mechanism: the mutation rate is firstly perturbated and then the 
#' resulting value is taken to mutate Lambda solution vector. The best solution is 
#' selected along with its mutation rate.
#'
#' @param dim integer, the dimension of the 
#' @param obj_func the objective function to be maximized
#' @param target double, the target value to hit 
#' @param budget integer, maximal allowable number of function evaluations
#' @param lambda_ integer, the population size > 1
#'
#' @export
#' @examples
self_adaptive_GA <- function(dim, obj_func, target = NULL, budget = NULL,
                             lambda_ = 10) {
  if (is.null(budget)) budget <- 10 * dim
  
  x <- sample(c(0, 1), dim, TRUE)
  xopt <- x
  fopt <- fx <- obj_func(x)
  budget <- budget - 1
  
  r <- 1.0 / dim
  tau <- 0.22
  
  while (budget > 0) {
    x_ <- tcrossprod(rep(1, lambda_), x)
    r_ <- (1.0 / (1 + (1 - r) / r * exp(tau * rnorm(lambda_))))  %*% t(rep(1, dim))
    idx <- matrix(runif(lambda_ * dim), lambda_, dim) < r_
    x_[idx] <- 1 - x_[idx]
    
    f <- obj_func(x_)
    budget <- budget - lambda_
    
    selected <- which(min(f) == f)
    x <- x_[selected, ]
    r <- r_[selected, 1]
    
    if (f[selected] > fopt) {
      fopt <- f[selected] 
      xopt <- x
    }
  }
  list(xopt = xopt, fopt = fopt)
}

#' Mutation operator for 1+lambda EA
#'
#'
#' @param ind The individual to mutate
#' @param mutation_rate The mutation rate
#'
mutate <- function(ind, mutation_rate){
  dim <- length(ind)
  mutations <- seq(0, 0, length.out = dim)
  while (sum(mutations) == 0){
    mutations <- sample(c(0, 1), dim, prob = c(1-mutation_rate, mutation_rate), replace = TRUE)
  }
  as.integer( xor(ind, mutations) )
}

#' A (1+lambda) EA implementation
#'
#' @param IOHproblem An IOHproblem object
#' @param lambda_ The size of the offspring
#' @param budget How many times the objective function can be evaluated
#'
#' @export
#' @examples
#' \donttest{
#' one_plus_two_EA <- function(IOHproblem) { one_plus_lambda_EA(IOHproblem, lambda_=2) }
#'
#' benchmark_algorithm(one_plut_two_EA, params.track = "Mutation rate",
#' algorithm.name = "one_plus_two_EA",
#' algorithm.info = "Using one_plus_lambda_EA with specific parameter" )
#' }
one_plus_lambda_EA <- function(IOHproblem, lambda_ = 1, budget = NULL) {
  dim = IOHproblem$dimension
  if (is.null(budget)) budget <- 10*dim
  obj <- IOHproblem$obj_func

  parent <- sample(c(0, 1), dim, TRUE)
  best <- parent
  mutation_rate <- 1.0/dim
  IOHproblem$set_parameters(mutation_rate)
  best_value <- obj(parent)
  budget <- budget-1

  while ( budget > 0 && !IOHproblem$taget_hit() ){
    for (i in 1:lambda_){
      offspring <- parent
      offspring <- mutate(offspring, mutation_rate)
      v <- obj(offspring)
      if(v > best_value){
        best_value <- v
        best <- offspring
      }
      budget <- budget - 1
      if (budget == 0 ) break
    }
    parent <- best
    mutation_rate = 1.0 / (1 + (1 - mutation_rate) / mutation_rate * exp(0.22 * rnorm(1)))
    mutation_rate = min(max(mutation_rate, 1.0/dim), 0.5)
    IOHproblem$set_parameters(mutation_rate)
  }
  return(best_value)
}


#' One-Comma-Lambda Genetic Algorithm with 2-rate self-adaptive mutation rate
#' 
#' A genetic algorithm that controls the mutation rate (strength) using the so-called 
#' 2-rate self-adaptation mechanism: the mutation rate is based on a parameter r. For
#' each generation, half offspring are generated by mutation rate 2r/dim, and half by 
#' r/2dim. r that the best offspring has been created with will be inherited by 
#' probability 3/4, the other by 1/4.
#'
#' @param IOHproblem An IOHproblem object
#' @param lambda_ integer, the population size > 1
#' @param budget How many times the objective function can be evaluated
#'
#' @export
#' @examples
two_rate_GA <- function(IOHproblem, lambda_ = 2, budget = NULL){
  dim = IOHproblem$dimension
  if (is.null(budget)) budget <- 100*dim
  obj <- IOHproblem$obj_func

  parent <- sample(c(0, 1), dim, TRUE)
  best <- parent
  r <- 2.0
  best_value <- obj(parent)
  budget <- budget-1

  while ( budget > 0 ){
    selected_r <- r;
    selected_obj <- Inf

    for (i in 1:lambda_){
      offspring <- parent

      if(i <= lambda_/2){
        mutation_rate = r / 2.0 / dim;
      } else{
        mutation_rate = 2.0 * r / dim;
      }
      offspring <- mutate(offspring, mutation_rate)

      v <- obj(offspring)
      if(v >= best_value){
        best_value <- v
        best <- offspring
      }
      if(v >= selected_obj){
        selected_obj = v
        selected_r = mutation_rate * dim;
      }
      budget <- budget - 1
      if (budget == 0 ) break
    }
    parent <- best
    if(runif(1) > 0.5){
      r = selected_r
    }
    else{
      if(runif(1) > 0.5){
        r = r / 2.0
      } else{
        r = 2.0 * r
      }

      if(r < 2.0) r = 2.0
      if(r > dim / 4.0) r = dim / 4.0
    }

  }
  return(best_value)
}